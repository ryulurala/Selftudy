[OT]

------------------------------------------------------------------------------------------------------------------------
[서버 OT]

*서버 : 다른 컴퓨터에서 연결이 가능하도록 대기 상태로 상시 실행 중인 프로그램 (ex 영업 중인 식당)

*게임 서버의 종류
1. Web Server(aka. HTTP Server)
- 음식을 받고, 이후론 연락 끊김. 질의/응답 형태. (ex 테이크아웃 포장 전문 식당)
- 드물게 정보 요청/갱신.
- 먼저 접근할 일이 없다. (ex 물 따라드릴까요? 등)
- 실시간 Interaction X
- ASP.NET(C#), Spring(Java), NodeJS(JavaScript), Django, Flask(Python), PHP, ...
- Stateless

2. Game Server(aka. TCP Server, Binary Server, Stateful Server ...)
- 실시간 Interaction이 있다. (ex 일반 식당)
- 요청/갱신 횟수가 많다.
- 실시간 Interaction이 필요.
- 언제라도 직원이 손님한테 접근 가능.
- Stateful
- 게임/장르에 따라 요구 사항이 다르다.
- 최적의 프레임워크라는 것이 존재하기 힘듬.

*식당 = 게임 서버 비유
- 손님 한도 = 최대 동시 접속자
- 손님의 일행 한도(인테리어) = 게임 장르 및 채널링
- 직원 역할 = 게임 로직(요리사), 네트워크(서빙), DB(결제)
- 직원 수 = 쓰레드 개수
- 요리사/서빙/결제 직원 비율 = 쓰레드 모델
- 주문 받는 방법 = 네트워크 모델
- 손님이 기다리는 시간 한도 = 반응성(FPS, MMORPG, ...)
- 장부 및 결제 = DB
------------------------------------------------------------------------------------------------------------------------
[환경 설정]

- VS code에서 최상위 폴더를 만들고 Project 하위 폴더로 Server, ServerCore, DummyClient를 만든다.
- 각각 Project이므로 각 위치에서 "dotnet new console"로 프로젝트를 기반을 다진다.
- DummyClient는 Client역할을 한다.(500~1000명으로 인식되도록 패킷을 전달해준다)
- Server는 실질적인 서버
- ServerCore는 Server가 사용하는 핵심 기능들을 넣어 놓는다.
- "dotnet new sln"을 통해서 최상위 폴더에 솔루션 파일을 만든다
- "dotnet sln add *로 해당 폴더부터 하위 폴더 모두를 검사하여 .csproj를 담는다.

------------------------------------------------------------------------------------------------------------------------
[멀티쓰레드 개론]

- 코어가 1개일 때, 빠른 시간으로 짧게 전환하여 프로그램을 실행한다.
- 스케줄링으로 코어가 우선순위를 정하여 중요한 프로그램은 실행 시간을 보장한다.
- Heap 영역(new), Data 영역(static 변수)는 공유하지만 Stack은 각자만의 것이 있다.
- 멀티쓰레드 환경은 직원을 많이 두어 효율적으로 굴러가게 해야 한다.

------------------------------------------------------------------------------------------------------------------------
[쓰레드 생성]
- C + W + Tab으로 빠른 콘솔 로그를 만들 수 있다.

- Main 함수가 사장이면 Thread는 직원을 고용하는 것이다.
- Main 함수가 죽으면 쓰레드도 죽는다.

* Thread 생성(= 정직원 고용) --- 길게 일을 할 때 쓴다.
1. System.Threading; : 쓰레드를 사용하기 위한 using
2. static void MainThread(Object state) : 함수를 정의하여 일을 정해준다.(static 전역으로 생성)
3. Thread thread = new Thread(MainThread) : MainThread 일을 하는 thread를 생성한다.
4. thread.Start(); : 쓰레드를 시작한다.
- thread.name = "..." : 쓰레드의 이름 지정
- thread.IsBackground = true; : C#은 Default로 ForeGround에서 돌지만(false이지만) BackGround로 돌게 한다.
- thread.join(); : BackGround 쓰레드가 끝날 때까지 기다린다.(C++도 같은 함수다)

* ThreadPool로 Thread 생성(= 단기 알바 고용) --- 짧게 일을 할 때 쓴다.
1. ThreadPool.QueueUserWorkItem(MainThread); : MainThread 함수의 일을 하는 Queue를 생성한다.(= 인력사무소)
- 인원 수를 설정 가능하지만 각자 무슨 일을 하는 것에 대한 것은 불가능하다.
- 재사용하여 효율적이다.
- ThreadPool.SetMinThreads(N, N); : 최소 인원을 정하는 함수, (인원 수, IO와 관련된 NetWork)
- ThreadPool.SetMaxThreads(N, N); : 최대 인원을 정하는 함수, 최대를 넘으면 먹통이 되는 단점이 있다.
- 먹통되는 단점을 Task로 해결 가능하다.
- ThreadPool.QueueUserWorkItem(obj => { while (true) { } });  // object를 받아서 => ...일을 해라.

* Task 생성(WorkThreadPool 단점 해결)
1. System.Threading.Tasks; : Task를 사용하기 위한 using
2. Task task = new Task(() => { while (true) { } }, TaskCreationOptions.LongRunning);
3. task.Start();
- ThreadPool에 포함되지만 옵션을 넣어서 별도 쓰레드로 생성하게 한다.
- 옵션이 없으면 먹통 상황은 같다.
- TaskCreationOptions.LongRunning : 오래 걸린다는 것을 알려주는 옵션.

------------------------------------------------------------------------------------------------------------------------
[컴파일러 최적화]

- Thread.Sleep(N); : N ms = 0.001N s를 Sleep한다.
- task.Wait(); : Thread의 Join()과 같다.(Background task가 아니어도 기다린다)

* 컴파일러의 코드 최적화
- Debug mode와 Release mode에서는 다르게 프로그램이 실행한다.
ex) Debug mode : while(bool){ ...; }
Release mode : if(bool){ while(true) { ...; }}
- 코드를 작성한 것이 while문 안에 bool형의 조건을 건드는 것이 없을 때 발생한다.

* 코드 최적화 방지
- 간단한 방법 : static bool 변수 명; -> volatile static bool 변수 명;
- volatile은 휘발성 데이터로 코드 작성한 그대로 쓰게 한다.
- volatile은 C++에서는 조금 다르다.
- volatile을 안쓰는 것을 권장한다.
- Lock, Memory Barrier 등으로도 할 수 있다.

------------------------------------------------------------------------------------------------------------------------
[캐시 이론]

- CPU 코어에는 ALU(연산 장치) + 캐시 장치가 있다.
- 캐시 장치에 기록해놓았다가 Ram(Main memory)에게 전달한다.

* Locality
- Tempolal Locality : 시간 - 최근 접근한 것이 또 접근할 확률이 높다.
- Spacial Locality : 공간 - 접근한 것의 근처에 접근할 확률이 높다.

- Single Thread 환경에서는 문제가 없지만 Multi Thread 환경에서는 잘못 전달되면 바꾸기 힘들다.

- C# 에서의 2차원 배열 : int[,] arr = new int[N, N]; -> 접근 방법 : arr[n, n];

* 시간 재는 법(Tick 하나는 100 ns = 1/10,000,000 s)
1. long now = DateTime.Now.Ticks;
2. long end = DateTime.Now.Ticks;
3. end - now

------------------------------------------------------------------------------------------------------------------------
[메모리 배리어]

- 컴파일러(S/W)말고도 H/W도 코드 최적화를 한다.(스케줄링 - 순서를 바꾼다)
- volatile로 컴파일러의 코드 최적화를 막지만 H/W는 못 막는다.

* 메모리 배리어 효과
1. 코드 재배치 억제
2. 가시성 : 실제 메모리에 Flush하는 느낌(동기화)

* 메모리 배리어 종류 : Full, Store, Load Memory Barrier가 있다.
1) Full Memory Barrier (ASM(어셈블리) : MFENCE, C# : Thread.MemoryBarrier) : Store/Load를 둘 다 막는다.
2) Store Memory Barrier (ASM : SFENCE) : Store만 막는다.
3) Load Memory Barrier (ASM : LFENCE) : Load만 막는다.

* 사용 방법
- Thread.MemoryBarrier();
- Store 후의 메모리 배리어, Load 전에 메모리 배리어를 사용한다.

- Task.WaitAll(Taks[]); : 기다릴 Task를 ','로 구분하여 파라미터에 넣는다.

------------------------------------------------------------------------------------------------------------------------
[Interlocked]

* 경합 조건(Race Condition)과 Interlocked
- 원자성(Atomic) : 고유하고 유일하다
- 컴퓨터의 최적화로 인해 값을 복사하여 사용하기 때문에 Atomic하지 않다.
- 따라서 Atomic하게 만들어 같은 것을 사용하게 하고 경합(Race)하게 한다.
- 경합이라는 것은 순서가 보장돼 있다.
- Interlocked.Increment(ref 변수 명); : Atomic하게 변수를 1 증가시킨다(주소 값을 넘기며 반환은 증가한 int 값이다)
- Interlocked.Decrement(ref 변수 명); : Atomic하게 변수를 1 감소시킨다(변수의 값을 모르며 메모리 배리어를 간접적으로 사용한다)

------------------------------------------------------------------------------------------------------------------------
[Lock 기초]

- InterLocked은 int형을 증가시키고 감소시키고 단순한 일만 가능하다.

* { Monitor.Enter(Object obj) ... Monitor.Exit(Object obj) }
- InterLocked보다 복잡한 일 가능.
- Enter와 Exit 사이에서는 싱글 쓰레드 환경처럼 Atomic하게 사용할 수 있다.
- 일종의 문을 잠구는 행위(obj는 자물쇠 역할)와 문을 여는 행위이다.
- 단점 : DeadLock 상태 발생
- DeadLock : Enter하고 Exit이 되지 않고 return; 이 되버리면 atomic한 변수를 다른 곳에서 사용할 때 무한정으로 기다리게 된다(먹통이 된다)
- 해결 :
1. try-finally로 finally는 Exception이 발생해도 한 번은 실행되는 것으로 해결한다.(코드가 복잡해진다)
2. lock(Object obj){ ... }을 사용한다.(대부분 이 방법 사용)

* Ex 문제 상황
Monitor.Enter(obj);
  ...
  return;
Monitor.Exit(obj);    // return 되어 DeadLock 발생.

1. try-finally 해결
try
{
  Monitor.Enter(obj);
  ...
  return;             // return 되어도 finally 함수를 한 번 실행하여 Exit해준다.
}
finally
{
  Monitor.Exit(obj);
}

2. lock(Object obj) 해결
lock(obj)
{
  ...
  return;       // 내부적으로 Monitor함수다. return; 되기 전에 자동으로 Monitor.Exit()을 처리해준다.
}

- 그래도 데드락은 *다른 조건(Object=자물쇠가 여러 개)*으로 발생한다.
- 데드락 발생하는 조건을 없애는 목적이다.

------------------------------------------------------------------------------------------------------------------------
[데드락(DeadLock)]

* DeadLock(교착 상태) 상황
- 여러 자원을 각자 가지고 서로 가지려고 할 때 발생하는 경우가 많다.
ex) A는 a를 가지고 있고 b를 가지려 할 동시에, B는 b를 가지고 있고 a를 가지려 할 때

* 해결 방법
- 처음부터 구조를 만들 때 데드락 상황이 일어나지 않도록 한다.
- 하지만 일반적인 경우, 
이미 Base는 다진 상태에서 유지 보수를 하게 된다면 Crash를 내어 데드락이 일어나는 상황을 보고 고치는 것이 현명하다(try-catch 방식)
- 사실 조금만 시간을 어긋나게 하면(Thread.Sleep(N); ) 발생하지 않을 수 있다.
- 주로 네트워크에서 일어나고 개발, QA 단계에서는 잘 발생하지 않고 출시하는 상황에서 많이 발생한다.
1. Monitor.TryEnter(Object obj, TimeSpan timeSapn); : 정해 놓은 시간만큼 시도하다 안되면 포기하게 한다.
2. ID를 부여하여 우선 순위를 부여하고 추적하여 데드락을 해결할 수도 있다.

------------------------------------------------------------------------------------------------------------------------
[Lock 구현 이론]

- 무작정 기다리기. - 단점 : 안나오면 내 일을 아예 못함
- 내 일을 하다가 나중에 다시 온다. - 단점 : 다시 돌아왔는데 다른 사람이 들어감
- 관리자가 중재 - 단점 : 관리자에게 비용이 들어감

------------------------------------------------------------------------------------------------------------------------
[SpinLock]






------------------------------------------------------------------------------------------------------------------------
[Context Switching]





------------------------------------------------------------------------------------------------------------------------
[AutoResetEvent]







------------------------------------------------------------------------------------------------------------------------
[ReaderWriterLock]




------------------------------------------------------------------------------------------------------------------------
[ReaderWriterLock 구현 연습]





------------------------------------------------------------------------------------------------------------------------
[Thread Local Storage]




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
