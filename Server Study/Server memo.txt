[OT]

------------------------------------------------------------------------------------------------------------------------
[서버 OT]

*서버 : 다른 컴퓨터에서 연결이 가능하도록 대기 상태로 상시 실행 중인 프로그램 (ex 영업 중인 식당)

*게임 서버의 종류
1. Web Server(aka. HTTP Server)
- 음식을 받고, 이후론 연락 끊김. 질의/응답 형태. (ex 테이크아웃 포장 전문 식당)
- 드물게 정보 요청/갱신.
- 먼저 접근할 일이 없다. (ex 물 따라드릴까요? 등)
- 실시간 Interaction X
- ASP.NET(C#), Spring(Java), NodeJS(JavaScript), Django, Flask(Python), PHP, ...
- Stateless

2. Game Server(aka. TCP Server, Binary Server, Stateful Server ...)
- 실시간 Interaction이 있다. (ex 일반 식당)
- 요청/갱신 횟수가 많다.
- 실시간 Interaction이 필요.
- 언제라도 직원이 손님한테 접근 가능.
- Stateful
- 게임/장르에 따라 요구 사항이 다르다.
- 최적의 프레임워크라는 것이 존재하기 힘듬.

*식당 = 게임 서버 비유
- 손님 한도 = 최대 동시 접속자
- 손님의 일행 한도(인테리어) = 게임 장르 및 채널링
- 직원 역할 = 게임 로직(요리사), 네트워크(서빙), DB(결제)
- 직원 수 = 쓰레드 개수
- 요리사/서빙/결제 직원 비율 = 쓰레드 모델
- 주문 받는 방법 = 네트워크 모델
- 손님이 기다리는 시간 한도 = 반응성(FPS, MMORPG, ...)
- 장부 및 결제 = DB
------------------------------------------------------------------------------------------------------------------------
[환경 설정]

- VS code에서 최상위 폴더를 만들고 Project 하위 폴더로 Server, ServerCore, DummyClient를 만든다.
- 각각 Project이므로 각 위치에서 "dotnet new console"로 프로젝트를 기반을 다진다.
- DummyClient는 Client역할을 한다.(500~1000명으로 인식되도록 패킷을 전달해준다)
- Server는 실질적인 서버
- ServerCore는 Server가 사용하는 핵심 기능들을 넣어 놓는다.
- "dotnet new sln"을 통해서 최상위 폴더에 솔루션 파일을 만든다
- "dotnet sln add *로 해당 폴더부터 하위 폴더 모두를 검사하여 .csproj를 담는다.

------------------------------------------------------------------------------------------------------------------------
[멀티쓰레드 개론]

- 코어가 1개일 때, 빠른 시간으로 짧게 전환하여 프로그램을 실행한다.
- 스케줄링으로 코어가 우선순위를 정하여 중요한 프로그램은 실행 시간을 보장한다.
- Heap 영역(new), Data 영역(static 변수)는 공유하지만 Stack은 각자만의 것이 있다.
- 멀티쓰레드 환경은 직원을 많이 두어 효율적으로 굴러가게 해야 한다.

------------------------------------------------------------------------------------------------------------------------
[쓰레드 생성]
- C + W + Tab으로 빠른 콘솔 로그를 만들 수 있다.

- Main 함수가 사장이면 Thread는 직원을 고용하는 것이다.
- Main 함수가 죽으면 쓰레드도 죽는다.

* Thread 생성(= 정직원 고용) --- 길게 일을 할 때 쓴다.
1. System.Threading; : 쓰레드를 사용하기 위한 using
2. static void MainThread(Object state) : 함수를 정의하여 일을 정해준다.(static 전역으로 생성)
3. Thread thread = new Thread(MainThread) : MainThread 일을 하는 thread를 생성한다.
4. thread.Start(); : 쓰레드를 시작한다.
- thread.name = "..." : 쓰레드의 이름 지정
- thread.IsBackground = true; : C#은 Default로 ForeGround에서 돌지만(false이지만) BackGround로 돌게 한다.
- thread.join(); : BackGround 쓰레드가 끝날 때까지 기다린다.(C++도 같은 함수다)

* ThreadPool로 Thread 생성(= 단기 알바 고용) --- 짧게 일을 할 때 쓴다.
1. ThreadPool.QueueUserWorkItem(MainThread); : MainThread 함수의 일을 하는 Queue를 생성한다.(= 인력사무소)
- 인원 수를 설정 가능하지만 각자 무슨 일을 하는 것에 대한 것은 불가능하다.
- 재사용하여 효율적이다.
- ThreadPool.SetMinThreads(N, N); : 최소 인원을 정하는 함수, (인원 수, IO와 관련된 NetWork)
- ThreadPool.SetMaxThreads(N, N); : 최대 인원을 정하는 함수, 최대를 넘으면 먹통이 되는 단점이 있다.
- 먹통되는 단점을 Task로 해결 가능하다.
- ThreadPool.QueueUserWorkItem(obj => { while (true) { } });  // object를 받아서 => ...일을 해라.

* Task 생성(WorkThreadPool 단점 해결)
1. System.Threading.Tasks; : Task를 사용하기 위한 using
2. Task task = new Task(() => { while (true) { } }, TaskCreationOptions.LongRunning);
3. task.Start();
- ThreadPool에 포함되지만 옵션을 넣어서 별도 쓰레드로 생성하게 한다.
- 옵션이 없으면 먹통 상황은 같다.
- TaskCreationOptions.LongRunning : 오래 걸린다는 것을 알려주는 옵션.

------------------------------------------------------------------------------------------------------------------------
[컴파일러 최적화]

- Thread.Sleep(N); : N ms = 0.001N s를 Sleep한다.
- task.Wait(); : Thread의 Join()과 같다.(Background task가 아니어도 기다린다)

* 컴파일러의 코드 최적화
- Debug mode와 Release mode에서는 다르게 프로그램이 실행한다.
ex) Debug mode : while(bool){ ...; }
Release mode : if(bool){ while(true) { ...; }}
- 코드를 작성한 것이 while문 안에 bool형의 조건을 건드는 것이 없을 때 발생한다.

* 코드 최적화 방지
- 간단한 방법 : static bool 변수 명; -> volatile static bool 변수 명;
- volatile은 휘발성 데이터로 코드 작성한 그대로 쓰게 한다.
- volatile은 C++에서는 조금 다르다.
- volatile을 안쓰는 것을 권장한다.
- Lock, Memory Barrier 등으로도 할 수 있다.

------------------------------------------------------------------------------------------------------------------------
[캐시 이론]

- CPU 코어에는 ALU(연산 장치) + 캐시 장치가 있다.
- 캐시 장치에 기록해놓았다가 Ram(Main memory)에게 전달한다.

* Locality
- Tempolal Locality : 시간 - 최근 접근한 것이 또 접근할 확률이 높다.
- Spacial Locality : 공간 - 접근한 것의 근처에 접근할 확률이 높다.

- Single Thread 환경에서는 문제가 없지만 Multi Thread 환경에서는 잘못 전달되면 바꾸기 힘들다.

- C# 에서의 2차원 배열 : int[,] arr = new int[N, N]; -> 접근 방법 : arr[n, n];

* 시간 재는 법(Tick 하나는 100 ns = 1/10,000,000 s)
1. long now = DateTime.Now.Ticks;
2. long end = DateTime.Now.Ticks;
3. end - now

------------------------------------------------------------------------------------------------------------------------
[메모리 배리어]

- 컴파일러(S/W)말고도 H/W도 코드 최적화를 한다.(스케줄링 - 순서를 바꾼다)
- volatile로 컴파일러의 코드 최적화를 막지만 H/W는 못 막는다.

* 메모리 배리어 효과
1. 코드 재배치 억제
2. 가시성 : 실제 메모리에 Flush하는 느낌(동기화)

* 메모리 배리어 종류 : Full, Store, Load Memory Barrier가 있다.
1) Full Memory Barrier (ASM(어셈블리) : MFENCE, C# : Thread.MemoryBarrier) : Store/Load를 둘 다 막는다.
2) Store Memory Barrier (ASM : SFENCE) : Store만 막는다.
3) Load Memory Barrier (ASM : LFENCE) : Load만 막는다.

* 사용 방법
- Thread.MemoryBarrier();
- Store 후의 메모리 배리어, Load 전에 메모리 배리어를 사용한다.

- Task.WaitAll(Taks[]); : 기다릴 Task를 ','로 구분하여 파라미터에 넣는다.

------------------------------------------------------------------------------------------------------------------------
[Interlocked]

* 경합 조건(Race Condition)과 Interlocked
- 원자성(Atomic) : 고유하고 유일하다
- 컴퓨터의 최적화로 인해 값을 복사하여 사용하기 때문에 Atomic하지 않다.
- 따라서 Atomic하게 만들어 같은 것을 사용하게 하고 경합(Race)하게 한다.
- 경합이라는 것은 순서가 보장돼 있다.
- *주의* : 경합하고 공유하는 원자성이 있는 멋대로 변수는 읽어서 사용하면 안된다(if 절)
- Interlocked.Increment(ref 변수 명); : Atomic하게 변수를 1 증가시킨다(주소 값을 넘기며 반환은 증가한 int 값이다)
- Interlocked.Decrement(ref 변수 명); : Atomic하게 변수를 1 감소시킨다(변수의 값을 모르며 메모리 배리어를 간접적으로 사용한다)

------------------------------------------------------------------------------------------------------------------------
[Lock 기초]

- Interlocked은 int형을 증가시키고 감소시키고 단순한 일만 가능하다.

* { Monitor.Enter(Object obj) ... Monitor.Exit(Object obj) }
- Interlocked보다 복잡한 일 가능.
- Enter와 Exit 사이에서는 싱글 쓰레드 환경처럼 Atomic하게 사용할 수 있다.
- 일종의 문을 잠구는 행위(obj는 자물쇠 역할)와 문을 여는 행위이다.
- 단점 : DeadLock 상태 발생
- DeadLock : Enter하고 Exit이 되지 않고 return; 이 되버리면 atomic한 변수를 다른 곳에서 사용할 때 무한정으로 기다리게 된다(먹통이 된다)
- 해결 :
1. try-finally로 finally는 Exception이 발생해도 한 번은 실행되는 것으로 해결한다.(코드가 복잡해진다)
2. lock(Object obj){ ... }을 사용한다.(대부분 이 방법 사용)

* Ex 문제 상황
Monitor.Enter(obj);
  ...
  return;
Monitor.Exit(obj);    // return 되어 DeadLock 발생.

1. try-finally 해결
try
{
  Monitor.Enter(obj);
  ...
  return;             // return 되어도 finally 함수를 한 번 실행하여 Exit해준다.
}
finally
{
  Monitor.Exit(obj);
}

2. *lock(Object obj) 해결* 많이 쓴다.
lock(obj)
{
  ...
  return;       // 내부적으로 Monitor함수다. return; 되기 전에 자동으로 Monitor.Exit()을 처리해준다.
}

- 그래도 데드락은 *다른 조건(Object=자물쇠가 여러 개)*으로 발생한다.
- 데드락 발생하는 조건을 없애는 목적이다.

------------------------------------------------------------------------------------------------------------------------
[데드락(DeadLock)]

* DeadLock(교착 상태) 상황
- 여러 자원을 각자 가지고 서로 가지려고 할 때 발생하는 경우가 많다.
ex) A는 a를 가지고 있고 b를 가지려 할 동시에, B는 b를 가지고 있고 a를 가지려 할 때

* 해결 방법
- 처음부터 구조를 만들 때 데드락 상황이 일어나지 않도록 한다.
- 하지만 일반적인 경우, 
이미 Base는 다진 상태에서 유지 보수를 하게 된다면 Crash를 내어 데드락이 일어나는 상황을 보고 고치는 것이 현명하다(try-catch 방식)
- 사실 조금만 시간을 어긋나게 하면(Thread.Sleep(N); ) 발생하지 않을 수 있다.
- 주로 네트워크에서 일어나고 개발, QA 단계에서는 잘 발생하지 않고 출시하는 상황에서 많이 발생한다.
1. Monitor.TryEnter(Object obj, TimeSpan timeSapn); : 정해 놓은 시간만큼 시도하다 안되면 포기하게 한다.
2. ID를 부여하여 우선 순위를 부여하고 추적하여 데드락을 해결할 수도 있다.

------------------------------------------------------------------------------------------------------------------------
[Lock 구현 이론]

- 무작정 기다리기. - 단점 : 안나오면 내 일을 아예 못함(SpinLock)
- 내 일을 하다가 나중에 다시 온다. - 단점 : 다시 돌아왔는데 다른 사람이 들어감(Context Switching)
- 관리자가 중재하기 - 단점 : 관리자에게 비용이 들어감(AutoResetEvent or ManualResetEvent, Mutex)

------------------------------------------------------------------------------------------------------------------------
[SpinLock]

* SpinLock
- 무작정 기다리기
- 동시에 들어갈 수도 있어 비교 연산을 사용하여야 한다.(0이면 1, 1이면 0)

* ex )
class SpinLock
{
  volatile bool _locked = false;  // 자물쇠

  public void Acquire() // Monitor.Enter(); 와 비슷하다.
  {
    // while(_locked){ // 잠금이 풀리기를 기다리는 행위}
    _locked = true; // 이제 자물쇠는 자신의 것
  }

  public void Release() // Monitor.Exit(); 와 비슷하다.
  {
    // 자물쇠를 돌려줌
    _locked = false;
  }
}

- 동시에 들어갔기 때문에 버그가 발생한다.

- 해결(원자 단위의 연산 사용)

1) Exchange(ref T location, T value) 사용 : location에 value 값으로 설정, return 값은 본래의 값
  volatile int _locked = 0;   // Exchange를 사용하기 위해 Type 변경
  
  public void Acquire()
  {
    while(true)
    {
      int original = Interlocked.Exchange(ref _locked, 1);  //_locked = 1;과 같다.
      if(original == 0) { break; }
    }
  }

2) CompareExchange(ref T location, T desire, T expected) 사용 : location이 expected 값이면 desire 값을 넣는다, return 값은 본래의 값
  volatile int _locked = 0;   // CompareExchange를 사용하기 위해 Type 변경

  public void Acquire()
  {
    while(true)
    {
      int original = Interlocked.Exchange(ref _locked, 1, 0); // if (_locked == 0) { _locked = 1; } 과 같다.
      if(original == 0) { break; }
    }
  }

- CompareExchange는 CAS, Compare-And-Swap 구조이다.

- Release(){ // 사실 자물쇠만 돌려주면 할 일이 없다.}

------------------------------------------------------------------------------------------------------------------------
[Context Switching]

* Context Switching
- 무작정 기다리지 않고 내 일을 하고 올게! 라는 의미
- 방법 3 가지 : 각각 장점과 단점이 있다.
  1) Thread.Sleep(N);    // 무조건 휴식 -> 무조건 N ms 정도 쉰다.
  2) Thread.Sleep(0);    // 조건부 양보 -> 나보다 우선순위 낮으면 양보 불가(다시 본인), 높거나 같으면 양보
  3) Thread.Yield();     // 관대한 양보 -> 실행 가능한 쓰레드에게 양보, 없으면 남은 시간 소진
- 순서
1. Register에 들어있는 State 값을 RAM에 저장
2. Switching
3. Register에 들어올 값 복원
- 비용이 비싸다

ex)
public void Acquire()
{
  while(true)
  {
    // 기다리기
    int original = Interlocked.Exchange(ref _locked, 1, 0); // if (_locked == 0) { _locked = 1; } 과 같다.
    if(original == 0) { break; }

    // 내 일을 하러 간다(쉬다 온다)
    Thread.Sleep(1);    // 무조건 휴식 -> 무조건 1ms 정도 쉰다.
    Thread.Sleep(0);    // 조건부 양보 -> 나보다 우선순위 낮으면 양보 불가(다시 본인), 높거나 같으면 양보
    Thread.Yield();     // 관대한 양보 -> 실행 가능한 쓰레드에게 양보, 없으면 남은 시간 소진
  }
}

- Sleep()을 실행하면 CPU 점유권을 포기하고 커널 모드로 들어가 OS에게 실행 권한을 넘겨준다.
- OS가 그 다음 실행할 쓰레드를 결정 : 오래 기다린 순서 + 중요도(Initialized)
- 현재 실행 중인 모든 쓰레드에서 Sleep과 같은 대기를 요청한 상태가 아닌 이상,
   남는 쓰레드가 없을 경우는 거의 없다고 보면 된다(실제 프로세스 개수 생각)
- 실제로는 모든 프로세스는 CPU Time Slice를 간절하기 받기를 원하는 상태이다.

------------------------------------------------------------------------------------------------------------------------
[AutoResetEvent]

* Auto Reset Event vs Manual Reset Event
- 관리자가 중재(관리자 = Kernel)
- 자동 vs 수동(쓰레드를 받아들일 문을 닫는 행위)
- 일종의 Kernel단에서의 Flag(bool) 개념이다.
- 다른 이유가 없다면 Auto가 더 깔끔하다(Manual은 두 차례 나눠서 하기 때문에 버그가 발생할 수 있다)
ex)
1) AutoResetEvent
AutoResetEvent _available = new AutoResetEvent(bool initialState);   // true : available, false : unavailable

public void Acquire()   // Monitor.Enter();
{
  _available.WaitOne(); // 입장 시도 : AutoResetEvent면 입장 후 바로 Auto로 닫아준다.
}
public void Release()   // Monitor.Exit();
{
    _available.Set();   // 문을 열어주는 행위. flag = true;
}

2) ManualResetEvent
ManualResetEvent _available = new ManualResetEvent(bool initialState);

public void Acquire()   // Monitor.Enter();
{
  _available.WaitOne(); // 입장 시도
  _available.Reset();   // 문을 닫아주는 행위. flag(bool) = false;  // Auto랑 차이
}
public void Release()   // Monitor.Exit();
{
    _available.Set();   // 문을 열어주는 행위. flag(bool) = true;
}

* Mutex
- Kernel 동기화 객체
- ResetEvent 보다 많은 State를 담고 있다. : Thread ID, Lock count 등
- ResetEvent 보다 조금 더 느리다.
- 클래스를 만들 필요 없이 Mutex 객체를 이용한다.
ex)
static Mutex _lock = new Mutex();
{
  _lock.WaitOne();
  ...
  _lock.ReleaseMutex();
}

------------------------------------------------------------------------------------------------------------------------
[ReaderWriterLock]

* Lock 종류 3가지
1. 근성 : _lock{ ... } : 내부에서는 Monitor로 되어 있다.
2. 양보 : Sleep(0), Sleep(N), Yield() 이용
3. 갑질 : 프로그램-프로그램단에서는 유리할 수 있다.

- 게임에 따라서 멀티쓰레드를 사용할 지 구분한다.
- 멀티쓰레드 환경은 난이도가 많이 높아진다.

* SpinLock 예시 : 사실 양보까지도 한다.
ex) 구현돼 있는 SpinLock API
static SpinLock _spinLock = new SpinLock();

  bool lockTaken = false;
  try
  {
    _spinLock.Enter(ref lockTaken);
  }
  finally
  {
    if(lockTaken){ _spinLock.Exit(); }  // Exception이 났을 경우
  }

* ReaderWriterLock
- 최종적으로는 DB에 저장되겠지만 DB부하와 다른 이유로 DB에서 긁어와 서버 메모리에서 처리해야 할 때가 있다.
- 특정 던전을 유도하기 위해 특정 시간에 운영자가 운영툴로 게임 보상을 추가해야한다면
   보상이 5개에서 6개로 오를 경우, Lock을 걸지 않고는 Data에 수정하기는 어렵다.
    이럴 경우, User들은 Read할 경우는 여러 번이지만 Write는 한 번이다.
     여기서 Lock을 같은 Writer의 같은 수준을 걸게 되면 낭비된다.
- ReaderWriterLock or ReaderWriterLockSlim 객체
: Read는 여러 번, Write는 한 번 정도의 Lock 수준을 걸고 싶을 때 사용한다.
- ReaderWriterLockSlim이 최신이다(더 많이 씀)

ex) 
static ReaderWriterLockSlim _rwLock = new ReaderWriterLockSlim();

static Reward GetRewardById(int _id)
{
  _rwLock.EnterReadLock();
  // ... User(여러 번)
  _rwLock.ExitReadLock();
  return null;
}
static void AddReward(int _id)
{
  _rwLock.EnterWriteLock();
  // ... VIP(한 번만)
  _rwLock.ExitWriteLock();
}

------------------------------------------------------------------------------------------------------------------------
[ReaderWriterLock 구현 연습]

* ReaderWriterLock 구현
1. 정책 : 재귀적 락을 허용할 지(Yes or No), 스핀락 정책(5000번 -> Yield)
- 재귀적 락(Yes): WriteLock->WriteLock(Ok), WriteLock->ReadLock(Ok), ReadLock->WriteLock(No)
- - const int MAX_SPIN_COUNT = 5000;

2. Bit Masking을 이용하여 원자성을 강조한다.
- const int EMPTY_FLAG = 0x00000000;
- const int WRITE_MASK = 0x7FFF0000;
- const int READ_MASK = 0x0000FFFF;
- int _flag = EMPTY_FLAG;
int형 32bits:
  [Unused(1)], : 음수가 되는 것을 방지
    [WriteThreadId(15)], : Write 한 번에 한 쓰레드만 잡을 때, 그 쓰레드 ID : 상호-배타적임
      [ReadCount(16)] : 여러 쓰레드들이 동시에 잡을 때, 쓰레드 개수

3. if) 재귀적 허용(Yes): int _writeCount = 0; // 상호-배타적이기 때문에 별도의 변수 가능

4. 함수 구현(4개)
  // Write Lock을 건다(여러 개가 동시에 들어와도 혼자만 가능)
  public void WriteLock()
  {
    // if) 재귀적 허용(Yes): 동일 쓰레드가 WriteLock을 이미 획득하고 있는지 확인
    int lockThredId = (_flag & WRITE_MASK) >> 16;
    if(Thread.CurrentThread.ManagedThreadId == lockThreadId)
    {
      // 동일 쓰레드가 획득 성공
      _writeCount++;
      return;
    }

    // 아무도 WriteLock or ReadLock을 획득하고 있지 않을 때, 경합하여 소유권을 얻는다.
    int desired = (Thread.CurrentThread.ManagedThreadId << 16) & WRITE_MASK;
    while(ture)
    {
      for(int i=0; i<MAX_SPIN_COUNT; i++)
      {
        // 시도를 해서 성공하면 return;

        // 잘못된 코드 예시
        if(_flag == EMPTY_FLAG)   // 1단계
        {
          _flag = desired;        // 2단계
          return;                 // 1단계를 동시에 통과하여 2단계를 할 수도 있으므로 버그가 생긴다.
        }

        // 올바른 코드
        if(Interlocked.CompareExchange(ref _flag, desired, EMPTY_FLAG) == EMPTY_FLAG)
        {
          _writeCount = 1;    // if) 재귀적 락(Yes)
          return;
        }
      }
    }

    // WriteLock을 실패했을 경우 양보한다.(1개만 (한 번 or 여러 번) 성공할 수 있기에)
    Thread.Yield();
  }

  // Write Lock을 가지고 있는 쓰레드가 UnLock 한다.
  public void WriteUnLock() 
  {
    int lockCount = --_writeCount;  // if) 재귀적 락(Yes)
    if(lockCount == 0)    // 한 개의 쓰레드가 여러 번 했을 경우 때문에
    {
      // WriteLock을 하고 있는 쓰레드만 WriteLock을 해제할 수 있다.
      Interlocked.Exchange(ref _flag, EMPTY_FLAG);    // 초기 상태로 바꿔준다(UnLock한다)
    }
  }

  // Read Lock을 한다. 여러 쓰레드가 동시에 들어와서 사용 가능
  public void ReadLock()
  {
    // 동일 쓰레드가 WriteLock을 이미 획득하고 있는지 확인
    int _lockThreadId = (_flag & WRITE_MASK) >> 16;
    if(Thread.CurrentThread.ManagedThreadId == _lockThreadId)
    {
      // 동일 쓰레드가 획득을 성공
      Interlocked.Increment(ref _flag);
      return;
    }

    // 아무도 WriteLock을 획득하고 있지 않으면, ReadCount를 1 증가시킨다.
    while(true)
    {
      for(int i=0; i<MAX_SPIN_COUNT; i++)
      {
        // 아무도 WriteLock을 획득하고 있지 않다.

        // 잘못된 예(in 멀티 쓰레드 환경)
        if((_flag & WRITE_MASK) == EMPTY_FLAG)  // 1단계
        {
          _flag = _flag + 1;                    // 2단계(Read한 쓰레드 개수 증가)
          return;                               // 1단계를 동시에 통과하여 1증가 버그 발생
        }

        // 올바른 예(in 멀티 쓰레드 환경) ****중요****
        int expected = (_flag & READ_MASK)  // WriteFlag를 0으로 Mask, if: A(0), B(0) 동시에 하고 다음에
        // A(0->1), B(0->1) 둘 중에 먼저 한 쓰레드만 통과 가능(나중은 다음 for문 턴에 가능)
        if(Interlocked.CompareExchange(ref _flag, expected+1, expected) == expected)
        {
          return;
        }
      }

      // 양보
      Thread.Yield();
    }
  }

  // Read UnLock을 한다. 여러 쓰레드가 동시에 들어와서 사용 가능
  public void ReadUnLock()
  {
    // UnLock한 애들 개수 1 감소
    Interlocked.Decrement(ref _flag);
  }

------------------------------------------------------------------------------------------------------------------------
[Thread Local Storage]

- 멀티 쓰레드 환경이 다 좋은 것만은 아니다.(비용이 있어서)

* TLS(Thread Local Storage)
- 쓰레드의 고유한 전역 변수: 다른 쓰레드에게는 영향을 주지 않는다.
- 쓰레드 하나가 일감을 모아서 사용하는 바구니 느낌이다.

ex 1) TLS(No)
static string ThreadName;   // 일반적인 전역 변수
static void WhoAmI()
{
  ThreadName = $"My Name is {ThreadName.CurrentThread.ManagedThreadId}";  // ThreadName 할당
  Thread.Sleep(1000);     // 혹시나 다른 쓰레드가 바꿔도 바뀌는지
  System.Console.WriteLine(ThreadName);
}
- ThreadName을 Thread들이 모두 공유해서 사용한다.
- 한 쓰레드가 이름을 출력할 때 ThreadName을 바꿔서 겹치는 버그가 발생한다

ex 2) TLS(Yes)
static ThreadLocal<string> ThreadName = new ThreadLocal<string>();
static void WhoAmI()
{
  // 자신의 영역의 이름을 바꾼다
  ThreadName.Value = $"My Name is {Thread.CurrentThread.ManagedThreadId}";
  Thread.Sleep(1000);     // 혹시나 다른 쓰레드가 바꿔도 바뀌는지
  System.Console.WriteLine(ThreadName.Value);
}

- ThreadName을 각 Thread들의 고유한 값으로 가지고 있다.(전역 변수여도)
- 하지만 ThreadPool의 Min과 Max의 값을 고정시키면 Thread Pooling으로 인해 동일한 쓰레드가 Repeat하는 경우가 생긴다.
ex 3) TLS(Yes), repeat환경 테스트
static ThreadLocal<string> ThreadName = new ThreadLocal<string>(()=>{
  return $"My name is {Thread.CurrentThread.ManagedThreadId}";
});
static void WhoAmI()
{
  bool repeat = ThreadName.IsValueCreated;    // true: 이미 한 번 만들었다, false: 만든적 없다
  if(repeat){ // 반복됨 ture: 이미 만들었었다. }
  else{ // 한 번도 만들지 않았다, value가 null일 때, 람다 실행}
}

- Parallel.Invoke(WhoAmI, WhoAmI, WhoAmI, WhoAmI, WhoAmI, WhoAmI, WhoAmI); :
매개 변수 넣는 만큼 ThreadPool에서 Task를 꺼내서 사용한다.

- ThreadName.Dispose(); : 람다식을 만든 것을 날린다.

------------------------------------------------------------------------------------------------------------------------
[네트워크 기초 이론]

* 통신 구조 vs 택배 구조
- 라우터 = 택배 배송업체
- 네트워크 = 아파트 단지(현대 아파트 or 삼성 아파트)
- 스위치 = 단지 내 경비실 
- 컴퓨터 = 집
- 사설 주소 = 김씨 집, 최씨 집
- 공식 주소(IP) = 201호, 502호

------------------------------------------------------------------------------------------------------------------------
[통신 모델]

* 통신 모델(TCP/IP-5Layer) vs 택배 모델
- 어플리케이션(UI: HTTP, FTP, DNS) = 상품
- 트랜스포트(전송 확인/오류 해결: TCP(MMO), UDP(FPS)) = 배송 정책
- 네트워크(네트워크 간 경로 설정: IPv4, IPv6, 장치: 라우터) = 집 최종 주소: 일정하다
- 데이터 링크(네트워크 내 경로 설정: 이더넷, PPP, 장치: 스위치) = 단지 경로
- 피지컬(신호 처리, 케이블/허브) = 택배 운송

* OSI-7Layer Model(before TCP/IP-5Layer)
- 어플리케이션(7) ---- 주소: 도메인(Domain)
- 프레젠테이션(6)
- 세션(5)
- 트랜스포트(4)
- 네트워크(3) ---- 주소: IP, 장치: 라우터
- 데이터링크(2) ---- 주소: MAC(기기에 따라 고정), 장치: 스위치
- 피지컬(1)

- 단계가 증가될 때마다 정보가 추가되어 합쳐서 보낸다.

------------------------------------------------------------------------------------------------------------------------
[소켓 프로그래밍 입문 #1]

* 식당(식당/손님) vs 소켓 구조(서버/클라이언트)
- 식당 입장:
  1) 문지기 고용 = Listener 소켓 준비
  2) 문지기 교육: 주소, 입구 = Bind(서버 주소 + Port를 소켓에 연동)
  3) 영업 시작 = Listen
  4) 안내 or 거절: 손님 연락 받고 대리인 입장 or 거절 = Accept
  5) 손님과 대리인 통화 = 클라이언트 대리인(Session)을 통해 송수신 가능

- 손님 입장:
  1) 휴대폰 준비 = 소켓 준비
  2) 식당 번호로 입장 문의 = 서버 주소로 Connect
  3) 안내 받은 대리인과의 통화 = 소켓을 통해 대리인(Session)소켓과 패킷 송수신 가능

------------------------------------------------------------------------------------------------------------------------
[소켓 프로그래밍 입문 #2]

* 주소 사전 처리(Server, Client 동일)
- 최종 주소를 알아내기 위한 DNS(Domain Name System) 사용
  string host = Dns.GetHostName();    // HostName을 가져온다. ex) SRChoi
  IPHostEntry ipHost = Dns.GetHostEntry(host);      // ex) System.Net.IPHostEntry
  IPAddress ipAddr = ipHost.AddressList[0];   // IP주소는 분산 서버에 따라 여러 개 출력 가능, ex) IP 주소
  IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);     // 최종 주소, Port는 입구 위치(정문, 후문) ex) IP 주소 + Port 번호

********** Server Socket 단계 **********
1) 소켓 생성: 문지기를 만든다.
// AddressFamily: IPv4 or IPv6(네트워크 망에 내장된 DNS서버에 의해 설정돼있다)
// SocketType.Stream, ProtocolType.Tcp: TCP(Stream을 쓰고 프로토콜은 TCP를 쓴다)
- Socket listenSocket = Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)

2) 소켓 연동: 문지기를 교육시켜 문의한 사람들만 안내한다.
// EndPoint = IP + Port
- listenSocket.Bind(EndPoint endPoint);

3) 소켓 열기: 입구를 연다.
// backlog: 최대 대기 수 Listen --- 동시 접근 발생 때문에
- listenSocket.Listen(int backlog);

4) 접속 허용: 사람을 안내한다.
// Accept()의 return: Session(대리인)의 Socket = 안내받은 대리인
- Socket clientSocket = listenSocket.Accept();
- Blocking 함수다. = 대리인이 입장을 안하면 무한정 대기한다.

5.0) 받을 데이터 크기 지정(사전 처리)
- byte[] recvBuffer = new Byte[N];    // Data Buffer

5.1) 데이터 수신: Client로부터 데이터를 받는다.
// Receive의 return: 받은 Byte 수
- int recvBytes = ClientSocket.Receive(byte[] buffer);

5.2) 받은 데이터 디코딩
// 문자 규약: Data Buffer, 읽을 시작 인덱스, Byte 수
- string recvData = Encoding.UTF8.GetString(byte[] bytes, int index, int count);

6.0) 전송할 데이터 인코딩(사전 처리)
- byte[] sendBuff = Encoding.UTF8.GetBytes(String string);

6.1) 데이터 송신: Client에게 데이터를 전송한다.
// 인코딩된 데이터 전송
- clientSocket.Send(byte[] buffer);

7) 클라이언트 연결 끊기
- clientSocket.Shutdown(SocketShutdown.Both); // 예고(옵션): 닫을거다, 듣기도 싫고 말하기도 싫다.
- clientSocket.Close();

- 혹시나 예외가 발생할 수도 있으니 소켓 2단계부터 try-catch()로 처리해준다.

********** Client Socket 단계 **********
1) 소켓 생성(주소 사전 처리 후): 대화할 휴대폰 설정
- Socket socket = new Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)

2) 접속 요청: 문지기한테 입장 문의
// 서버 주소(Endpoint = IP + Port)로 연결 요청
- socket.Connect(EndPoint endPoint);
- Blocking 함수로 무한정 대기한다(게임에서 치명적)

3.0) 전송할 데이터 크기와 인코딩(사전 처리)
- byte[] sendBuff = Encoding.UTF8.GetBytes(String string);

3.1) 데이터 송신: Server session(대리인)에게 데이터를 전송한다.
// SendBuff에 있는 것을 한 번에 보냄
- int sendBytes = socket.Send(sendBuff);
- Blocking 함수로 Server session이 받질 못하면 무한정 대기한다(게임에서 치명적)

4.0) 받을 데이터 크기 지정
- byte[] recvBuff = new Byte[N];

4.1) 데이터 수신: Server session(대리인)으로부터 데이터를 받는다.
- int recvBytes = socket.Receive(byte[] buffer);
- Blocking 함수로 Server session으로부터 받질 못하면 무한정 대기한다(게임에서 치명적)

4.2) 받은 데이터 디코딩
- string recvData = Encoding.UTF8.GetString(byte[] bytes, int index, int count);

5) 연결 끊기: Server session(대리인)와의 연결을 끊는다.
- socket.Shutdown(SocketShutdown.Both);   // 예고(옵션)
- socket.Close();

- 혹시나 예외가 발생할 수도 있으니 소켓 2단계부터 try-catch()로 처리해준다.

------------------------------------------------------------------------------------------------------------------------
[Listener]

* Listener 클래스를 만들어 Refectoring한다.
- 비동기 방식은 두 단계로 나누어야 한다(RegisterAccept(등록), AcceptCompleted(완료))

ex) 비동기 Listener 방식
class Listener
{
  Socket _listenSocket;       // ServerSocket
  Action<Socket> _onAcceptHandler      // Event action
  
  // 초기화 함수
  public void init(IPEndPoint endPoint, Action<Socket> onAcceptHandler)
  {
    // TCP, Stream을 사용하는 ServerSocket
    _listenSocket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
    _onAcceptHandler += onAcceptHandler;  // 매개 변수의 Event 등록
    _listenSocket.Bind(endPoint);     // 소켓 연동
    _listenSocket.Listen(int backlog);    // 소켓 열기: 동시 접속자일 때, 최대 대기수(backlog)

    // 이벤트 방식으로 비동기 구현(콜백으로 전달)
    SocketAsyncEventArgs args = new SocketAsyncEventArgs();       // 비동기 Event Arguments
    args.Completed += new EventHandler<SocketAsyncEventArgs>(OnAcceptCompleted);    // 이벤트 핸들러에 등록
    RegisterAccept(args);   // 초기화 단게에서 미리 등록(예약)
  }

  // Accept를 예약한다.
  public RegisterAccept(SocketAsyncEventArgs args)
  {
    args.AcceptSocket = null;   // 두 번째부터 기존에 들어있던 값을 초기화해야한다.
    bool pending = _listenSocket.AcceptAsync(args);   // return: pending(보류) 여부, Async: 비동기=안되면 return먼저
    if(pending == false)
    {
      // 클라이언트 접속 완료(보류가 false가 되었기 때문에)
      OnAcceptCompleted(null, args);
    }
    // 접속 보류됨(클라이언트 접속 안함, 서버는 return 시켰음)
  }
  // EventHandler<TEventArgs>(Object sender, TEventArgs e)이기 때문에 매개 변수 일치 시킴
  public OnAcceptCompleted(Object sender, SocketAsyncEventArgs args)
  {   // 데드존
    // Accept가 성공했는지 확인(SoccetError로 체크 가능)
    if(args.SocketError == SocketError.Success) // 별도의 쓰레드로 실행해줌
    {
      // Accept 성공, 서버가 해줘야 할 일
      // _onAcceptHandler를 소유한 쓰레드가 args.AcceptSocket 처리
      _onAcceptHandler.Invoke(args.AcceptSocket);
    }
    else
    {
      // 에러 처리(성공 이외의)
    }
    RegisterAccept(args);  // 다음 턴을 위해 등록(예약)
  }
}

- OnAcceptHandler 함수에서 Recieve, Send, close 처리

------------------------------------------------------------------------------------------------------------------------
[Session #1]

- 스택 오버플로우가 발생하지 않도록 AsycEventArg를 많이 둔다.(현실적으로 스택오버플로우 X)

* Session
- 보내고 받고 종료를 담당한다
- Receive
- Send
- Disconnect

ex) 비동기로 Receive() 구현: 비동기므로 두 단계(준비, 1.등록, 2.완료)로 구분된다.
class Session
{
  Socket _socket;
  volatile int _disconnected = 0;

  public void start(Socket socket)
  {
    _socket = socket;   // ClientSocket
    SocketAsyncEventArgs recvArgs = new SocketAsyncEventArgs();   // 비동기 이벤트
    recvArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnRecvCompleted);  // 자동 콜백

    // new SocketAsyncEventArgs().UserToken : 식별자 or 연동하고 싶은 데이터를 받고 싶을 때 사용

    // SetBuffer(메모리, offset, count)
    // Session끼리 버퍼를 나눠서 쓸 때를 위해 offset과 count가 있다.
    recvArgs.SetBuffer(new byte[1024], 0, 1024);

    // 등록(예약)
    RegisterRecv(recvArgs);
  }

  void RegisterRecv(SocketAsyncEventArgs args)
  {
    // Non-blocking 버전의 Receive
    bool pending = _socket.ReceiveAsync(args);  // 예약 확인하면서 Event를 호출하여 보낸다.
    if(pending == false)
    {
      // 받는 것을 성공
      OnRecvCompleted(null, args);    // Send 이벤트가 얘를 호출한다.
    }
  }

  void OnRecvCompleted(object sender, SocketAsyncEventArgs args)
  {
    // 상대방이 연결을 끊으면 가끔 0 byte로 온다.
    if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
    {
      // TODO(Connect: 데이터 받음)
      try
      {
        // (버퍼, offset(어디부터 시작), 받은 바이트 수)
        string recvData = Encoding.UTF8.GetString(args.Buffer, args.Offset, args.BytesTransferred);

        // Receive를 받을 준비를 다시 함
        RegisterRecv(args);
      }
      catch(Exception e)
      {
        // 에러 처리
      }
    }
    else
    {
      // TODO Disconnect
      Disconnect();
    }
  }

  public void Disconnect()
  {
    // Disconnect를 두 번하면 에러 난다.
    // _disconnected = 1, original value 1이면 또 close() 못하도록 함
    if(Interlocked.Exchange(ref _disconnected, 1) == 1)
    {
      return;
    }

    // 쫓아낸다
    _socket.Shutdown(SocketShutdown.Both);
    _socket.close();
  }
}

------------------------------------------------------------------------------------------------------------------------
[Session #2]

- Send()함수의 비동기적 호출은 Receive의 비동기적 호출과는 다르다.
    이유는 Receive는 언제 올 지를 알지만 Send는 언제 할 지를 모르기 때문이다.

ex) 비동기로 Send() 구현: 비동기므로 두 단계(준비, 1.등록, 2.완료)로 구분된다.
- 필드 변수
object _lock = new Object();    // lock을 쓰기 위해서
Queue<byte[]> _sendQueue = new Queue<byte[]>();     // sendBuff를 넣고 한 번에 보내기 위해서
bool _pending;    // 다른 쓰레드가 예약했는지 구분
SocketAsyncEventArgs _sendArgs = new SocketAsyncEventArgs();    // 재사용 하기 위해서

- 멤버 함수
public void start(Socket socket)
{
  // Receive용
  ...
  ...
  ...
  // Send용
  _sendArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnSendCompleted);   // 자동 콜백
}

public void Send(byte[] sendBuff)   // 언제 할 지 예측 불가하다.
{
  lock(_lock)   // 다른 쓰레드 들어오기 방지용
  {
    _sendQueue.Enqueue(sendBuff);   // Queue에만 넣고 스킵하는 쓰레드 발생 가능
    if(_pending == false)   // 첫 번째로 Send() 호출.(전송까지 가능하다)
      RegisterSend();
  }
}

void RegisterSend()
{
  // 이미 앞에 Send()함수에서 lock을 걸어서 호출하기 때문에 락을 걸 필요 X
  _pending = true;
  byte[] buff = _sendQueue.Dequeue();
  _sendArgs.SetBuffer(buff, 0 buff.Lenth);

  // SendAsync를 여러 번 호출하면 부하가 심하다.
  bool pending = _socket.SendAsync(_sendArgs);    // 예약 확인 하면서 sendArgs의 이벤트가 발생하여 보낸다
  if(pending == false)
  {
    // 보내는 것이 성공
    OnSendCompleted(null, _sendArgs);
  }
}

void OnSendCompleted(object sender, SocketAsyncEventArgs args)
{
  lock(_lock)   // Start에서 들어오는 쓰레드가 있을 수도 있어서 락을 걸어준다.
  {
    // 상대방이 연결을 끊으면 가끔 0 byte로 오기 때문에
    if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
    {
      try
      {
        // 다른 쓰레드가 Enqueue했던 것을 처리해야한다.
        // 내가 예약하고 나서 pending = false; 하기 전에 다른 쓰레드가 예약을 했을 경우
        if(_sendQueue.Count>0)
        {
          RegisterSend();     // 내가 그 쓰레드가 Enqueue한 것을 처리한다.
        }
        else
        {
          _pending = false;   // 최종적으로 false(예약 취소)
        }
      }
      catch(Exception e)
      {
        // 에러 출력
      }
    }
    else
    {
      // 상대방과 연결을 끊어짐
      Disconnect();
    }
  }
}

- 다른 쓰레드가 와서 버퍼를 계속 쓰기 때문에 완벽하게 해결되지는 않았다.

------------------------------------------------------------------------------------------------------------------------
[Session #3]





------------------------------------------------------------------------------------------------------------------------
[Session #4]



------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

