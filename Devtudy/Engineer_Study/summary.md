---
title: "요약"
category: 정보처리기사
tags: [정보처리기사2021]
---

## 애자일(Agile)

- 애자일(Agile)

  > 개발과 함께 즉시 피드백을 받아 유동적으로 개발하는 소프트웨어 개발 방법론

  - 특징
    - 프로젝트의 요구사항은 모듈 중심보다 **기능 중심**으로 정의
    - 절차와 도구보다 **개인과 소통**을 중시
    - 짧은 작업 계획 -> 요구 변화에 유연하고 신속하게 대응
    - 소프트웨어가 잘 실행되는 데 가치를 둠
    - 고객과의 피드백을 중시
  - 선언문
    1. 공정과 도구보다 개인과 상호작용
    2. 계획을 따르기보다 변화에 대응하기
    3. 포괄적인 문서보다 동작하는 소프트웨어
    4. 계약 협상보다 고객과의 협력
  - 유형

    - XP(eXtreme Programming)

      > 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론

      - `용기`, `단순성`, `의사소통`, `피드백`, `존중`
      - `Pair Programming`, `Collective Ownership`, `CI(Continuous Integration)`, `Planning Process`, `Small Release`, `Mehaphor`, `Simple Design`, `TDD(Test Driven Develop)`, `Refactoring`, `40-Hour Work`, `On Site Custormer`, `Coding Standard`

    - Lean

      > 낭비 요소를 제거해 품질을 향상시킨 방법론

      - `낭비 제거`, `품질 내재화`, `지식 창출`, `늦은 확정`, `빠른 인도`, `사람 존중`, `전체 최적화`

    - SCRUM
      > 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론

---

## 공통 모듈 설계

### 모듈

- 모듈

  > 독립된 하나의 S/W or H/W 단위

  - 단독 컴파일 가능, 재사용 가능
  - **결합도는 낮게**, **응집도는 높게**, **크기는 작게** 만들어야 Best!!
  - **복잡도는 낮게**, **중복성을 줄이고**, **일관성 유지**
  - 모듈의 기능은 예측 가능해야 하며, 지나치게 제한적이면 안 된다.

  - 원칙 5가지

    - 정확성(Correctness)
    - 명확성(Clarity)
    - 완전성(Completeness)
    - 일관성(Consistency)
    - 추적성(Traceability)

  - 팬인(Fan-In), 팬아웃(Fan-Out)
    - 모듈 자신을 기준으로 들어오면 팬인(in) - 깊이가 높아지면 들어옴
    - 모듈 자신을 기준으로 나가면 팬아웃(out) - 깊이가 낮아지면 나감

### S/W 설계 유형

- 상위 설계

  1. 자료 구조 설계(Data Structure Design)
     > 요구 분석 단계의 정보를 바탕으로 필요한 자료구조로 변환
  2. 아키텍처 설계(Architecture Design)
     > S/W 시스템의 전체 구조 기술, 컴포넌트 간의 관계 정의
  3. 인터페이스 설계(Interface Design)
     > 컴퓨터 시스템, 사용자 등이 어떻게 통신하는지를 기술
  4. 프로시저 설계(Procedure Design)
     > 프로그램 아키텍처 컴포넌트 -> S/W 컴포넌트의 프로시저 기술 변환

- 하위 설계

  1. 협약에 의한 설계(Design by Contract)
     > S/W 컴포넌트에 대한 인터페이스, 클래스 명세를 위한 선행 조건, 결과조건, 불변조건을 나타내는 설계 방법

- 코드 설계

  - 기능

    - `표준화`, `분류`, `식별`, `배열`, `간소화`, `연상`, `암호화`, `오류 검출`

  - 설계 종류
    - 연상 코드(Mnemonic Code)
      > 코드만 보고 대상을 연상  
      > ex) 한국: KS, 미국: US, ...
    - 블록 코드(Block Code)
      > 공통성 있는 것끼리 그룹화, `구분 코드`  
      > ex) 지역번호 - 국번 - ...
    - 순차 코드(Sequence Code)
      > 일정한 기준에 따라 순서대로 일련번호 부여한 코드  
      > ex) 중고등 학생들의 반 번호(가나다순으로 1번, 2번, ...)
    - 표의 숫자 코드(Significant Digit Code)
      > 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등을 표시한 코드  
      > ex) 20-100-300(길이 - 넓이 - 용량)
    - 십진 코드
      > 10진수 형태로 표현한 코드  
      > ex) 상품 바코드(880)
    - 그룹 분류식 코드
      > 대상을 기준에 따라 대분류, 중분류, 소분류로 구분해 번호 부여한 코드  
      > ex) 학번(입학 연도 - 일련번호 조합)

### HIPO

- HIPO(Hierarchy Input Process Output)

  > 시스템의 분석 및 설계, 문서화할 때 사용되며, **하향식 S/W 개발**을 위한 문서

  - 차트 종류
    - 가시적 도표(Visual Table of Content)
    - 총체적 도표(Overview Diagram)
    - 세부적 도표(Detail Diagram)

### S/W 아키텍처

- S/W Architecture

  > 여러 S/W 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 구성요소 간의 관계를 표현

  - 아키텍처는 시스템의 비기능적인 요소에 집중, 기능적인 요소도 고려.

  - S/W 아키텍처 프레임워크 구성요소

    - 아키텍처 명세서(Architectural Description)
      > 아키텍처를 기록하기 위한 산출물들
    - 이해관계자(Stakeholder)
      > 시스템 개발에 관련된 모든 사람과 조직
    - 관심사(Concerns)
      > 시스템에 대해 이해관계자들의 서로 다른 의견과 목표
    - 관점(Viewpoint)
      > 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식
    - 뷰(View)
      > 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현
    - 근거(Rationale)
      > 아키텍처 결정 근거
    - 목표(Mission)
      > 시스템의 목적, 사용, 운영방법
    - 환경(Environment)
      > 시스템에 영향을 주는 요인
    - 시스템(System)
      > 각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등의 구현체

  - S/W Architecture 4+1 뷰

    > 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 S/W 적인 접근 방법

    - 1
      - 유스케이스 뷰(Use-case View)
        > 다른 뷰를 검증하는데 사용되는 뷰
    - 4
      - 논리 뷰(Logical View)
        > 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
      - 프로세스 뷰(Process View)
        > 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
      - 구현 뷰(Implementation View)
        > 정적인 S/W 모듈의 구성을 보여주는 뷰
      - 배포 뷰(Deployment View)
        > 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

  - 비용 평가 모델 종류

    - SAAM(Software Architecture Analysis Method)
      > 변경 용이성과 기능성에 집중.
    - ATAM(Architecture Trade-off Analysis Method)
      > **아키텍처 품질 속성**을 만족시키는지 판단 및 품질 속성들의 이해 상충 관계까지 평가.
    - CBAM(Cost Benefit Analysis Method)
      > ATAM 바탕의 분석 중심으로 **경제적 의사결정에 대한 요구를 충족**하는 비용 평가 모델
    - ADR(Active Design Review)
      > 소프트웨어 아키텍처 구성요소 간 **응집도**를 평가
    - ARID(Active Reviews for Intermediate Designs)
      > 전체 [X], **특정 부분에 대한 품질요소**에 집중하는 비용 평가

  - S/W 아키텍처 패턴

    > 개발 시간을 단축, 높은 품질의 S/W 생산  
    > 개발의 안정적 수행, 시스템 특성 예측 가능

    - 계층화 패턴(Layered Pattern)
      > 시스템을 계층(Layer)으로 구분해 구성하는 패턴
    - 클라이언트-서버 패턴(Client-Server Pattern)
      > 하나의 서버와 다수의 클라이언트로 구성된 패턴
    - 파이프-필터 패턴(Pipe-Filter Pattern)
      > 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
    - 브로커 패턴(Broker Pattern)
      > 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 원격 서비스 실행을 통해 상호작용이 가능한 패턴
    - 모델-뷰-컨트롤러 패턴(MVC, Model-View-Controller Pattern)
      > 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화하는 패턴

---

## 객체지향 설계

### 객체지향

- 객체지향

  > 실세계의 개체를 객체(속성+메서드)로 표현하는 기법

  - 구성요소

    - 클래스(Class)
      > 데이터를 추상화하는 단위
    - 객체(Object)
      > 구현할 대상으로 각각의 상태와 식별성을 가짐.
    - 메서드(Method)
      > 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산
    - 메시지(Message)
      > 객체 간의 상호작용 수단
    - 인스턴스(Instance)
      > 실제로 메모리상에 할당된 각각의 객체
    - 속성(Property)
      > 객체들이 가지고 있는 데이터 값들을 단위별로 정의

  - 기법

    - 캡슐화(Encapsulation)
      > 관련성 높은 데이터와 함수들을 한 묶음으로 처리
    - 상속성(Inheritance)
      > 상위 클래스의 속성과 메소드를 하위 클래스에서 재정의 없이 물려받아 사용
    - 다형성(Polymorphism)
      > 하나의 메시지에 대해 각 객체가 고유한 방법으로 응답.  
      > ex) 오버로딩(Overloading), 오버라이딩(Overriding)
    - 추상화(Abstraction)
      > 공통 성질을 추상 클래스로 설정
    - 정보은닉(Information Hiding)
      > 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스로만 접근 가능하도록 하는 코드 보안 기술  
      > Side-Effect들을 최소화
    - 관계성(Relationship)
      > 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법.

  - 설계 원칙(`S` `O` `L` `I` `D`)

    - 단일 책임의 원칙(`S`ingle Responsibility Principle)
      > 하나의 클래스는 하나의 목적을 위해 생성.
    - 개방 폐쇄 원칙(`O`pen Close Principle)
      > S/W 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야 함.
    - 리스코프 치환의 원칙(`L`iskov Substitution)
      > 서브 타입(하위 클래스)은 자신의 기반 타입(상위 클래스)로 교체 가능해야 함.
    - 인터페이스 분리의 원칙(`I`nterface Segregation)
      > 클래스 내에 사용하는 않는 인터페이스는 구현하지 말아야 함.
    - 의존성 역전의 원칙(`D`ependency Inversion Principle)
      > 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만듦.

  - 객체지향 방법론 종류
    - OOSE(Object Oriented Software Engineering)
      > 유스케이스를 모든 모델의 근간으로 활용
    - OMT(Object Modeling Technology)
      > 4단계: 객체지향 분석, 시스템 설계, 오브젝트 설계, 구현  
      > 럼바우의 객체지향 분석 절차: 객체 모델링 -> 동적 모델링 -> 기능 모델링
    - OOD(Object Oriented Design)
      > 설계 부분만 존재.  
      > 미시적(Micro) 개발 프로세스 + 거시적(Macro) 개발 프로세스 사용

### 디자인 패턴

- 디자인 패턴

  > S/W 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법

  - 개발 효율성, 유지보수성, 상호운용성, 프로그램 최적화

  - 구성요소

    - 패턴 이름
    - 문제 및 배경
    - 솔루션
    - 사례
    - 결과
    - 샘플 코드

  - 패턴 유형

    - 목적
      - 생성, 구조, 행위
    - 범위
      - 클래스(컴파일 타임), 객체(런타임)

  - 디자인 패턴 종류

    - 생성 패턴
      - Builder
        > 단계별로 캡슐화해 구축 공정을 동일하게 이용하는 패턴
      - Prototype
        > 복사해 새 개체를 생성하는 패턴
      - Factory Method: `if-else` or `switch` 사용
        > 인스턴스 생성 처리를 서브 클래스가 결정하도록 하는 패턴
      - Abstract Factory: `interface` 사용
        > 생성군들을 하나에 모아놓고 팩토리 중에서 선택하게 하는 패턴
      - Singleton
        > 유일한 하나의 인스턴스를 보장하도록 하는 패턴
    - 구조 패턴
      - Bridge
        > 추상과 구현을 분리해 결합도를 낮춘 패턴
      - Decorator
        > 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
      - Facade
        > 하나의 인터페이스로 느슨한 결합을 제공하는 패턴
      - Flyweight
        > 대량의 작은 객체들을 공유하는 패턴
      - Proxy
        > 대리인이 대신 그 일을 처리하는 패턴
      - Composite
        > 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴, 일괄적인 관리
      - Adapter
        > 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴
    - 행위 패턴

      - Interpreter
        > 언어 규칙 클래스를 이용하는 패턴
      - Template Method
        > 알고리즘 골격의 구조를 정의한 패턴
      - Chain of Responsibility
        > 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
      - Command
        > 요청 자체를 캡슐화해 파라미터로 넘기는 패턴  
        > ex) Job Queue, Packet Queue
      - Iterator
        > 내부 표현은 보여주지 않고 순회하는 패턴
      - Mediator
        > 객체 간 상호작용을 캡슐화한 패턴
      - Memento
        > 상태 값을 미리 저장해 두었다가 복구하는 패턴
      - Observer
        > 상태가 변할 때 의존자들에게 알리고, 자동 업데이트하는 패턴
      - State
        > 객체 내부 상태에 따라서 행위를 변경하는 패턴
      - Strategy
        > 다양한 알고리즘을 캡슐화해 알고리즘 대체가 가능하도록 한 패턴
      - Visitor
        > 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴

    - 장점

      > 재사용, 소스 코드 변경 최소화, 개발자 간의 원활한 의사소통 가능

    - 단점
      > 초기 투자 비용의 부담

---

## 데이터 입출력 구현

### 자료 구조

- 자료 구조(Data Structure)

  > 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조.

  - 선형 구조
    > 데이터를 연속적으로 연결한 자료 구조
    - List
      - `Linear List`
        > 배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트  
        > **접근 빠름**, **삽입 및 삭제 느림**
      - `Linked List`
        > 노드의 포인터로 서로 연결시킨 리스트  
        > **접근 느림**, **삽입 및 삭제 빠름**
    - `Stack`
      > 한 방향으로만 자료를 넣고 꺼내는 구조  
      > LIFO(Last-In First_Out) 구조
    - `Queue`
      > 한쪽은 삽입만, 한쪽은 삭제만 작업하는 자료 구조  
      > FIFO(First-In First-Out) 구조
    - `Deque`(Double Ended Queue)
      > 양쪽 모두 삽입, 삭제 가능한 자료 구조
  - 비선형 구조
    > 데이터를 비연속적으로 연결한 자료 구조
    - `Tree`
      > 데이터들을 계층화시킨 자료 구조  
      > Node + Link 로 구성됨.
    - `Graph`
      > Node(노드) + Edge(간선)을 하나로 모아 놓은 자료 구조

### 논리 데이터 저장소

- 논리 데이터 저장소

  > 업무를 모델링 표기법으로 형상화한 데이터 저장소

  - 개체(Entity): 직사각형
    > 관리할 대상이 되는 실체
  - 속성(Attribute): 원
    > 관리할 정보의 구체적 항목
  - 관계(Relationship): 마름모
    > 개체 간의 대응 관계

---
