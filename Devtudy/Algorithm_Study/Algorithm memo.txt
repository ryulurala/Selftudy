[C++]

<STL: Standard Template Library>

*** using namespace std; ***
- 가독성을 위해서

************************ 출력 : <iostream> 사용 ************************
- #inlcude <iostream>
cout << ... ; : ... 출력(연산자 오버로딩 돼있다)
cout << endl; : 개행

************************ vector 컨테이너 ************************
- LIFO 구조(Stack)
- 공간(Capacity)은 기존 메모리의 *2로 증가한다.

1. <vector> 헤더 선언
- #include <vector>

2. 생성자
ex) vector<Data type> 변수 명;
- vector<T> v; : vector 컨테이너 v 선언
- vector<T> v(n) : Default값(0)으로 초기화된 n개가 들어있는 v 선언
- vector<T> v(n, element) : element로 초기화된 n개가 들어있는 v 선언
- vector<T> v2(v1) : v2 선언(v1을 복사한)

3. 멤버 함수(if: vector<T> v1; vector<T> v2;)
할당
- v1.assign(n, N) : N의 값으로 n개의 원소 할당(이전 값을 삭제하고 할당)
- v1.reserve(n) : n개의 위치 예약(미리 동적 할당)

조회
- v1.at(index) or v[index] : 값 참조(느림, 안전 or 빠름, 불안전)
- v1.front() / v.back() : 첫 번째 원소 참조 / 마지막 원소 참조 (이므로 v.back()+= v.front()가 가능하다)
- v1.begin() / v1.end() : 첫 번째 원소 / 마지막의 *다음* 포인터 리턴(iterator 사용)
- v1.size() / v1.capacity() : 원소 개수 리턴 / 공간 크기 리턴
- v1.empty(); : v1이 비어있으면 true, 원소가 있으면 false, 공간과 관계X

삽입
- v1.push_back(element) : 마지막 원소 뒤에 element 삽입
- v1.resize(n) : 크기를 n으로 변경(커진 메모리는 0으로 초기화)
- v1.insert(iterator, element) : iterator위치에 element삽입(삽입한 위치 iterator 리턴)
- v1.insert(iterator, n, element) : iterator위치에 element으로 초기화된 n개 삽입(밀린다)
- v1.insert(v1.end(), v2.begin(), v2.end()) : v1에 v2를 이어 붙인다.(v1 + v2)
삭제
- v1.pop_back() : 마지막 원소 제거
- v1.clear() : 모든 원소 제거(원소만 제거, 메모리는 유지)
- v1.erase(iterator) : iterator가 가리키는 원소 제거(공간은 그대로), 
                          제거한 다음 원소를 가리키는 Iterator 리턴,
                            앞으로 원소들을 당기기 때문에 비효율적


************************ Map 컨테이너(노드기반 균형 이진트리 구조) ************************
- 검색용(key로 value검색)
- Key만 있는 것은 "set"이다. (set은 insert(key)로 넣어주자.)

- (Key, Value) : Key 중복 불가능(중복 가능한 것은 <multimap>)
- 비슷한 컨테이너: <set>, <multiset>
- 삽입 후 자동 오름차순 정렬
- 반복자로 순회: ex)
map<T, T> m;
map<T, T>::iterator iter;
for(iter = m.begin(); iter != m.end(); iter++)
  cout<< iter->first << ", " << iter->second << endl; // 순회

1. <map> 헤더 선언
- #include <map>

2. 생성자
- map<T, T> m : 기본 선언(pair<T, T>로 받는다)
- map<T> m2(m1) : m2를 선언(m1을 복사한)
- map<T1, T2, greater<T1>> m : 내림차순 map 선언

3. 멤버 함수(if: map<T, T> m1; map<T, T> m2;)
할당
X

조회
- m1.find(key) : key값에 해당하는 iterator 리턴
- m1.find(key)->second : key값에 해당되는 value값
- m1.empty() : 비어있으면 true, 노드가 있으면 false
- m1.count(key) : key값의 value값 개수 리턴
- m1.size() : 노드 개수 리턴
- m1.begin() / m1.end() : 첫 번째 원소 / 마지막의 *다음* 포인터 리턴(iterator 사용)

삽입
- m1.insert(pair<key, value>) / m1[key] = value : pair 객체로 삽입 / []연산자로 삽입, 수정
    ex) m1.insert(make_pair(key, value))

삭제
- m1.clear() : 모든 원소 제거
- m1.erase(iter) : iter 가리키는 원소 삭제(지워진 곳 가리켜서 에러 발생)
- m1.erase(start, end) : start~end 범위 삭제 ex) m1.erase(m1.begin(), m1.end());
- ***m.erase(Key) : key로 삭제***

- if(m1.find(key) == m1.end()):"중복이 아닐 때"라는 뜻 = "end() 까지 갔는데도 중복된게 없다" 라는 뜻, 중복을 검사한다.(set도 마찬가지)
- Multimap, MultiSet을 이용하여 중복된 것이 있는지 검사하려면 key를 넣고 key의 count 개수를 확인하면 된다. ex) m.count(key);

************************ Queue 자료구조(덱(Deque) or List 구조) ************************
- FIFO 구조(queue)

1. <queue> 헤더 선언
- #include <queue>

2. 생성자
- queue<T> q : 기본 선언
- queue<T, list<T>> q; : list 구조 queue 선언(default: deque 구조)

3. 멤버 함수(if: queue<T> q)
할당
X

조회
- q.front() / q.back() : 첫 번째 원소 리턴 / 마지막 원소 리턴
- q.empty() : 큐가 비어있으면 true, 원소가 있으면 false
- q.size() : 큐 안에 원소 개수 리턴

삽입
- q.push(element) : 마지막 다음에 value값 삽입
- swap(q, emt) : emt는 비어있는 큐로 clear할 때 유용하다.

삭제
- q.pop() : 가장 처음 원소 삭제

************************ 우선순위 큐(Priority_Queue) 자료 구조(vector, deque 컨테이너 기반) ************************
1. <queue> 헤더 선언
- #include <queue>

2. 생성자
- priority_queue<T> pq; : 기본 선언
    (default(넣은 방향 기준 오름차순): less<T>) --- top은 큰 것부터 먼저 나온다

- priority_queue<T, deque<T>> pq; : deque 구조 선언(default: vector<T>)

- priority_queue<T, vector<T>, greater<T>> pq; : vector 구조,
    넣은 방향 기준 내림차순 정렬 방식 선언(top은 작은 것부터 나온다)

3. 멤버 함수(if: priority_queue<T> q)
할당
X

조회
- q.empty() : 우선순위 큐가 비어있으면 true, 원소가 있으면 false
- q.size() : 우선순위 큐 안에 원소 개수 리턴
- q.top() : top 원소 리턴(pop()하면 삭제될 원소)

삽입
- q.push(element) : 

삭제
- q.pop() : top의 원소를 삭제

* Priority_Queue에서 쓰도록 compare클레스 구조체로 정의
ex) : value값으로 key값 정렬하고 value값이 같을 경우 key값으로 정렬(일반 sort의 cmp와 부등호가 반대이다)
struct cmp{
  bool operator()(pair<int, int> a, pair<int, int> b){
    if(a.second == b.second)
      return a.first < b.first;
    else
      return a.second < b.second;
  }
};  // 구조체라서 세미콜론(;) 필수


************************ String 클래스(STL은 아님) ************************
1. <string> 헤더 선언
- #include <string>

2. 생성자
- string s : 기본 선언
- string s(str) : s를 선언(str을 복사한)
- string s(n, c) : s를 선언(n개의 c문자로)

3. 멤버 함수(if: string str1, string str2)
할당
- str1.resize(n, c) : n만큼 resizing : 작으면 삭제, 크면 남은 공간 c로 삽입
- str1.reserve(n) : 미리 n만큼 capacity 예약

조회
- str1.at(index) / str1[index] : index위치 문자(char형) 리턴
- str1.front() / str1.back() : 맨 앞 문자(char) / 맨 뒤 문자(char) 리턴
- str1.size() / str1.length() : str1의 길이 리턴
- str1.capacity() : str1의 할당된 공간 크기
- str1.empty() : 비어있으면 true, 원소가 있으면 false
- str1.begin() / str1.end() : st1의 처음 / 마지막에서 다음을 가리키는 iterator 리턴
- str1.find("s") : "s"가 있는 인덱스 리턴, 없으면 (int)형 변환할 때 string::npos 리턴
- str1.find("s", from index) : from index부터 "s"를 찾아서 인덱스 리턴, 없으면 string::npos 리턴
ex) if(string::npos == str1.find(s)) { 못찾았다.}

* 포함 관계(str1 = "abcd"; str2 = "ad";)
ex 1) find() 함수
if(string::npos != str1.find(str2))
: if 절은 false가 된다.(못찾는다.)

ex 2) includes() 함수(in <algorithm>)
includes(str1.begin(), str1.end(), str2.begin(), str2.end())
: 부분 집합으로 찾기 때문에 bool 값 true가 리턴된다.

삽입
- str1.push_back(char);
- str1.pop_back();
- str1 += str2; 연산자 오버로딩이 되어있어 가능하다

삭제
- str1.clear() : 문자열을 지운다(capacity는 그대로)

변환
- str1.c_str() : string(C++)을 char*(C)로 바꿔준다.
- str1.substr() / str1.substr(from) / str1.substr(from, count) :
    그대로 / from부터 끝까지 / from부터 count개수만큼 부분 문자열 리턴
- str1.replace(pos, count, str2) : 문자열 대체, pos(iterator) 부터 count개수만큼 str2로 바꿈
- to_string(T t) : T형의 t를 string으로 변환
- stoi(string str, &pos) : string 형 str을 int로 바꿈(참조), 숫자 외에 문자를 만날 시 pos개수를 바꿨다고 리턴.(size_t pos), int형 pos는 에러 발생, 반복문에는 segment fault 조심하자.
ex 1) stoi(str); : str을 int형으로 바꾼다(숫자가 아니기 전까지)
ex 2) stoi(str, nullptr, 2) : str이 2진수로 생각하며(only 0 or 1) int 값을 변환한다.
** stoi 주의: 처음부터 숫자가 아니면 exception을 발생시킨다.


ex) 문자열 대체 예제
1) str1.replace(from, count, str2) : from에서 count개수만큼 str2로 대체
2) str1.replace(str1.find(""), "".length(), str2) : str1에서 찾은 문자열을 대체
- str1.find("...") : "..."을 찾는다.

************************ 정렬-Sort(Algorithm 클래스) ************************

default 정렬은 무조건 less<T>: 먼저 넣은 방향 기준 안쪽으로 더 작은 것이 있다. (오름차순)
  (우선순위 큐도 default는 less<T>지만 나오는 방향에서는 내림차순이다)

ex) value값을 비교하여 key값 정렬 예제
bool cmp(pair<T, T> a, pair<T, T> b)
{
  return a.second < b.second; // value가 작은게 (선) 큰게 (후)
}
vector<pair<T, T>> v;
sort(v.begin(), v.end(), cmp); : 퀵정렬   --- 불안정
stable_sort(v.begin(), v.end(), cmp); : 병합정렬      --- 안정(같은 것에 대해 두 번 비교할 때 사용)
sort_heap(v.begin(), v.end(), cmp); : 힙정렬    --- 안정
************************ DFS(깊이 우선 탐색) ************************
* 실제로 구현할 때는 vector<int> node[N]; 을 선언하고
// m과 n를 연결할 때는 다음과 같이 한다.
node[m].push_back(n);
node[n].push_back(m);

- 2 가지 방법으로 만든다.(재귀 or Stack)
1) node는 전역 변수로 선언
2) 함수의 매개 변수를 참조자로 정의

------- 재귀 구현 -------
ex) 연결된 개수 리턴하는 재귀 DFS
  int dfsByRecursive(Node root)
  {
    if(root.check==true)
    {
      // TODO 코드(방문 끝남)
      return 1;   // 개수 하나씩 증가
    }

    // 방문 처리
    root.check = true;
    
    // 원소 개수
    int count = 0;

    for(int i=0; i<root.size(); i++)
    {
      // 인접한 노드를 방문
      count += dfs();
    }
    return count;
  }

------- 스택 구현 -------
ex) 연결된 개수 리턴하는 DP DFS
  int dfsByStack(Node root)
  {
    // 원소 개수
    int count = 0;

    // 스택 선언
    vector<int> stack;
    
    // 스택에 시작 값 삽입
    stack.push_back(root);

    // 방문 처리
    root.check = true;

    // DFS 시작
    while(!stack) // 스택에 값이 없을 때까지
    {
      // 스택에 값이 있다면 아직 방문하지 않은 노드가 있다.

      // TODO 코드(방문 끝남)
      count++;
      Node node = stack.back();
      stack.pop_back();
      
      for(int i=0; i<node.size(); i++)
      { // 방문하지 않았으면 스택에 삽입
        if(node[i].check == false)
        {
          stack.push_back(node[i]); // 다음에 갈 노드
          node[i].check = true;     // 방문 처리
          stack.push_back(node);    // 현재 노드(pop을 했기 때문에 돌아가려면 필요)
          break;
        }
      }
    }    
  }

************************ BFS(너비 우선 탐색) ************************
ex) 연결된 개수 리턴하는 DP BFS
  int bfsByQueue(Node root)
  {
    // 원소 개수
    int count = 0;

    // 큐 선언
    queue<int> q;

    // 큐에 시작 값 삽입
    q.push(root);

    // 방문 처리
    root.check = true;

    // BFS 시작
    while(!q.empty())   // 큐에 값이 없을 때까지.
    {
      // 큐에 값이 있다면, 아직 방문하지 않은 노드가 있다.

      // TODO 코드(방문 끝남)
      count++;
      Node node = q.front();
      q.pop();    

      // 방문하지 않는 노드 검사
      for(int i=0; i<node.size(); i++)
      {
        // 방문하지 않았으면 큐에 삽입
        if(node[i].check == false)
        {
          q.push(node[i]);
          node[i].check = true;   // 방문 처리
        }
      }
    }
    return count;
  }

************************ Union_Find(집합 만들기 알고리즘) ************************
vector<int> root; // 각 root
vector<int> rank; // 트리의 높이를 저장
vector<int> nodeCount;

for(int i=0; i<root.size(); i++)
{
  root.push_back(i);    // root를 자신으로 초기화
  rank.push_back(0);    // 트리의 높이 초기화
  nodeCount.push_back(1)  // 노드 개수 초기화
}

int find(int x)
{ // 루트 노드는 부모 노드 번호로 자기 자신을 가진다.
  if(x == root[x]) 
    return x;
  else // 각 노드의 부모 노드를 찾아 올라간다.
    return find(root[x]);
}

int union(int x, int y)
{
  x = find(x);  // x의 root 찾기
  y = find(y);  // y의 root 찾기

  // 두 값의 root가 같지 않을 때
  if(x != y)
  {
    root[y] = x;  // y의 root를 x로 변경
    nodeCount[x] += nodeCount[y];   // x의 node 수에 y의 node 수를 더한다.
    nodeCount[y] = 1;   // y의 node 수는 1로 초기화
  }
  return nodeCount[x];
}

************************ Algorithm 클래스 ************************
* 순열(Permutation)
- 완전 탐색

* 조합
1) 보조 수열로 해당 개수만큼 배열을 만든다.
2) 뽑을 개수만큼 앞에서부터 1을 채운다.
3) prev_permutation을 돌린다.(보조수열의 iterator로)
4) 1로 채워진 곳이 해당 인덱스의 값을 대체하면 된다.

* 멤버 함수
- next_permutation(처음 반복자, 끝 반복자) : 다음 자리를 바꾼다. (sort less 해야됨 = 오름차순으로 바꿔야댐)
- prev_permutation(처음 반복자, 끝 반복자) : 전 자리를 바꾼다. (sort greater 해야됨 = 내림차순으로 바꿔야댐)

ex) 자리를 바꿔가며 조건 검사 예제
do
{
  // 조건 검사
}
while(next_permutation(container.begin(), container.end()));

- is_permutation(v1.begin(), v1.end(), v2.begin(), v2.end()) : v2는 v1의 순열인지 확인. bool 값 return

* 중복 있는 합치기
- merge 함수
ex)
vector<int> result(v1.size()+v2.size());
merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()) : result는 미리 공간을 할당해야하며 중복허용하며 merge한다.

* 중복 없이 합치기
vector<int> result(v1.size()+v2.size());
vector<int>::iterator iter;
1) iter = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()) : v1합집합v2
2) iter = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()) : v1교집합v2
3) iter = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()) : v1-v2, 반대로 하려면 v2부터 매개변수를 넣으면 된다.
- result.resize(iter - result.begin()) : 결과의 끝을 return한 iterator이기 때문에 resize해주어야 한다.
- result.erase(iter, result.end()) : iter부터 end()까지 지운다.

* 부분 집합 판별
vector<int> v1;
vector<int> v2;
bool check = includes(v1.begin(), v1.end(), v2.begin(), v2.end());
if(check == true) : v2는 v1의 부분집합이다. v2 C v1

* 대소문자 변환(for auto 문으로 바꾸려면 참조자를 써야한다.)
#include <cctype>   // ::toupper, ::tolower
#include <algorithm>  // transform
transform(string.begin(), string.end(), string.begin(), ::toupper);   // :: 필수
transform(string.begin(), string.end(), string.begin(), ::tolower);
또는 
- 소문자가 ASCII 코드 값이 더 크다는 점을 이용하여
1) 소문자 -> 대문자: '문자' -= '소문자'(를) - '대문자'(로);
2) 대문자 -> 소문자: '문자' -= '대문자'(를) - '소문자'(로);

* 거꾸로 뒤집기(<algorithm> 헤더에 있음)
reverse(str.begin(), str.end()); : string을 거꾸로 뒤집는다.

* min(), max()
min(const T& a, const T& b): 작은거 리턴
max(const T& a, const T& b): 큰거 리턴
ex)
max(1, 2) -> 2 리턴
min('b', 'd') -> 'b' 리턴

************************ 소수 구하기 ************************
* 소수 구하기
1) 에라토스테네스의 체: 체로 걸어서 남는 수가 소수이다.
2) 해당 수가 소수인지 판별: 그 수의 root까지 반복문을 돌려 모두 나머지가 0이면 소수이다.

************************ 주의 ************************
float, double 등의 부동 소수점 비교는 정확하지 않다.
35.001 != 35.001 인 경우도 있다.
따라서, 부동 소수점의 범위 내에서 전부 곱하여 정수 상태로 비교한다.

************************ 구조체 ************************
typedef struct Name{
  int a, b, c, d;
  Robot(int _a, int _b, int _c, int _d){    // 생성자
    a = _a;
    b = _b;
    c = _c;
    d = _d;
  }
  Robot(const Robot& robot){      // 복사 생성자
    a = robot.a;
    b = robot.b;
    c = robot.c;
    d = robot.d;
  }
  bool operator ==(const Robot& robot){       // 비교 연산자 오버로딩
    if(a != robot.a) return false;
    if(b != robot.b) return false;
    if(c != robot.c) return false;
    if(d != robot.d) return false;
    return true;
  }
  void operator =(const Robot& robot){        // 대입 연산자 오버로딩
    a = robot.a;
    b = robot.b;
    c = robot.c;
    d = robot.d;
  }
}Name;

main()
{
  Robot robot1(0, 0, 0, 0);  
  Robot robot2(1, 1, 1, 1);
  if(robot1 == robot2){
    return 1;
  }
  return 0;
}

************************ 튜플(tuple)<tuple>  ************************
- pair 객체는 first, second 두 개만 사용 가능하지만, tuple은 다수의 개가 가능하다.

#include <tuple> 헤더 선언

int main()
{
    tuple<int, int, int, int> t;      // 튜플 선언
    t = make_tuple(1, 2, 3, 4);       // make_tuple로 추가

    printf("<before>\n");
    printf("%d\n", get<0>(t));        // 조회, 0, 1, 2, 3은 0부터 시작하는 Index다.
    printf("%d\n", get<1>(t));        // 특정 변수 Index로 조회할 수 없다.
    printf("%d\n", get<2>(t));
    printf("%d\n", get<3>(t));

    get<2>(t) = 10;               // 수정도 가능
    get<3>(t) = 20;

    printf("<after>\n");
    printf("%d\n", get<0>(t));
    printf("%d\n", get<1>(t));
    printf("%d\n", get<2>(t));
    printf("%d\n", get<3>(t));

    return 0;
}

-> 1, 2, 3, 4 출력 후 1, 2, 10, 20이 출력됨.



************************ 중복 가능한 map, set(multimap, multiset) ************************
#include <map>          // 헤더 선언

multimap<int, int> mm;

for(iter = mm.lower_bound(N); iter != mm.upper_bound(N); iter++){     // Key가 N인 value 값들 조회
  cout << "[" << iter->first << ", " << iter->second << "] " ;
}

--------
#include <set>          // 헤더 선언

multiset<int> ms;

multiset<int>::iterator start, end;

start = ms.lower_bound(N);        // 원소 N을 가리키는 처음 위치
end = ms.upper_bound(N);          // 원소 N을 가리키는 마지막 위치


************************ 반복자(iterator)  ************************

일반 순회
for(auto iter = vector.begin(); iter!=vector.end(); iter++){
  ... 앞에서부터
}

거꾸로 순회
for(auto riter = vector.rbegin(); riter!=vector.rend(); riter++){
  ... 뒤에서부터
}

************************    ************************
************************    ************************
************************    ************************
************************    ************************
************************    ************************
